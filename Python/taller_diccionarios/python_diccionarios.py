# -*- coding: utf-8 -*-
"""Python_basics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PyxXOKUmPboVrqhzy-zYLZWAFAO29ecU

# Diccionarios en Python:

El diccionario de Python es un contenedor de conjuntos desordenados de elementos tales como numero, texto y listas. En términos de funcionamiento, los diccionarios son parecidos a las listas, con la salvedad de que sus elementos son pares de datos tipo **llave:valor**.

Entre las principales características tenemos:

*   Se representan por { }
*   Son dinámicos en tamaño. Es decir, pueden agrandarse y encogerse según la necesidad del problema.
*   Pueden contener otras estructuras de datos en su interior.
*   Son editables.
*   "Puede contener elementos repetidos."

\\

Ejemplo: \\
dict = {clave1:valor1, clave2:valor2, ...}

\\

![fig_diccionario](https://drive.google.com/uc?export=view&id=1SSja_Su1z3hSkBa8TfW7rKrnkvoo7oGN)

## Inicializando diccionarios:
"""

# Un diccionario vacío puede definirse de la siguiente manera:
empy_dict_1 = {}
print("empy_dict_1= ", empy_dict_1)

# ó, utilizando la función dict():
empy_dict_2 = dict()
print("empy_dict_2 = ", empy_dict_2)

"""## Es importante recordar que los diccionarios siguen la estructura:

![fig_diccionario](https://drive.google.com/uc?export=view&id=16ywMD2HjJpGwU_s-yBDwehviSvuppCdf)

Entonces podemos definir el siguiente diccionario de países y capitales:
"""

country_capital_dict = {
    'Lima': 'Perú',
    'Buenos Aires': 'Argentina',
    'Bogotá': 'Colombia',
    'Montevideo': 'Uruguay'
    }

print(country_capital_dict)

placa_auto = {
    'LMN123': "Mazda CX5 2020",
    'OUN789': "BMW X3 2021"
}

"""## Nota:
Otras formas de crear el aterior diccionario pueden ser las siguientes:
"""

# Usando asignación a la llave pricipal:
country_capital_dict = dict(
    Lima='Perú',
    Buenos_Aires='Argentina',
    Bogotá='Colombia',
    Montevideo='Uruguay'
    )

print(country_capital_dict)

# Usando una lista de tuplas:
country_capital_dict = dict([
    ('Lima', 'Perú'),
    ('Buenos_Aires', 'Argentina'),
    ('Bogotá', 'Colombia'),
    ('Montevideo', 'Uruguay')
    ])

print(country_capital_dict)

"""## Obteniendo datos del diccionario:"""

# Definimos el diccionario a usar (pueden crear uno nuevo si quieren):
print(country_capital_dict)

# llamamos al valor que corresponde a la primera llave
# (Recordemos que siempre buscamos por llave):
print("\n")
print(f"key = Lima ---> country_capital_dict['Lima'] = {country_capital_dict['Lima']}")
print(f"key Bogotá ---> country_capital_dict['Bogotá'] = {country_capital_dict['Bogotá']}")

"""## Añadiendo datos a un diccionario:"""

# Diccionario para estudiantes y notas:
student_notes_dict = {
    'Juan': 4,
    'Sandra': 4.4,
    'Pepe': 4.3,
    'Sofia': 4,
    'Carlos': 4.5,
    "Sebastian": 3.1
}

print(student_notes_dict)

# Añadiendo un nuevo estudiante con su nota:
student_notes_dict['Julieta'] = 4.2 # Analicemos esta línea de código
print(student_notes_dict)

"""## Removiendo datos de un diccionario:"""

del student_notes_dict['Pepe'] # Analicemos esta línea de código

print(student_notes_dict)

"""## Métodos de diccionarios:
Analicemos un poco la estructura de los diccionarios y sus métodos.
"""

# Miremos primero el tipo de estructura dentro de python que es un diccionario.
print(type(student_notes_dict))

# Entonces podemos ver sus métodos haciendo:
# print(dir(student_notes_dict))
dir(student_notes_dict)

"""## El método get():
Este método sirve para accesar/obtener los valores de un diccionario buscando por su llave.
"""

# get():
score = student_notes_dict.get('Juan')
print(score)

"""## el método update():
Actualiza el diccionario con un nuevo par de datos tipo key:value. En caso de que la llave ya exista en la estructura, el valor que ésta contiene será reemplazado por el nuevo valor.
"""

# Usamos el método update() para añadir otro elemento al diccionario:
print(student_notes_dict)
student_notes_dict.update({'Juan': 5})
print(student_notes_dict)

# Acutalizar diccionario con un nuevo valor:
student_notes_dict.update({'Juana de Arco': 5})
print(student_notes_dict)

"""## Método Pop:
Remueve un elemento de un diccionario y retorna su valor asociado.
"""

# Generando dicctionario:
country_capital_dict = {
    'Lima': 'Perú',
    'Buenos Aires': 'Argentina',
    'Bogotá': 'Colombia',
    'Montevideo': 'Uruguay'
    }

# Diccionario de paises y capitales:
print(f"Diccionario original = {country_capital_dict}")
print("\n")
capital_poped = country_capital_dict.pop('Lima')
print(f"Capital del país eliminado del diccionario = {capital_poped}")
print("\n")
print(f"Diccionario modificado = {country_capital_dict}")
#

# Pop con valor por defecto:
# country_capital_dict.pop(key, default)

"""## Método keys:
Extrae todas las llaves de un diccionario
"""

numbers_dict = {1: 'one', 2: 'two', 3: 'three'}

# extracts the keys of the dictionary
keys = numbers_dict.keys()
print(keys)
print(type(keys))
print(list(keys))
print(tuple(keys))

"""## Método Values
Retorna los valores asociados a las llaves del diccionario
"""

numbers_dict = {1: 'one', 2: 'two', 3: 'three'}

# extracts the values of the dictionary
values = numbers_dict.values()
print(values)
print(type(values))
print(list(values))
print(tuple(values))

"""## Método Items:
Retorna un objeto tipo vista con la lista de los elementos de un diccionario organizados en tuplas.
"""

# Diccionario usado
print(f"Diccionario usado: {country_capital_dict}")
print("\n")

# Método items:
items = country_capital_dict.items()
print(items)
print(type(items))
print(list(items))
print(tuple(items))

"""## Método Clear
Elimina los elementos de un diccioanrio y lo retorna vacío.
"""

print(f"Diccionario original = {numbers_dict}")
print("\n")
numbers_dict.clear()
print(f"Diccionario modificado = {numbers_dict}")

"""# Cliclos en Python

Los ciclos, también conocidos como bucles, son una parte esencial de la programación en Python y en muchos otros lenguajes de programación. Los ciclos permiten ejecutar un bloque de código repetidamente, lo que ahorra tiempo y evita la repetición de tareas manuales.

En Python, hay dos tipos principales de ciclos: **for** y **while**

## Ciclo **for**:
El ciclo **for** se utiliza cuando sabemos de antemano cuántas veces queremos repetir un bloque de código. Es ideal para recorrer secuencias como listas, tuplas, diccionarios y rangos predefinidos.
"""

nombres = ["Alice", "Bob", "Charlie", "Pedro", "100", "200"]
for nombre in nombres:
    print("Hola, " + nombre)

"""Ciclo **while**:

El ciclo **while** se utiliza cuando no sabemos cuántas veces se repetirá un bloque de código. El ciclo seguirá ejecutándose mientras una condición sea verdadera.
"""

contador = 1
while contador <= 5:
    print("Iteración " + str(contador))
    contador += 1

"""Diferencias clave:

Usar ‘for’ cuando se conoce el número de iteraciones previamente.
Usar ‘while’ cuando la cantidad de iteraciones depende de una condición.
Evitar bucles infinitos en ‘while’ asegurándote de que la condición cambie en algún momento.

## Diccionarios:

1.   Escriba un programa que ordene los elementos de un diccionario en forma ascendente de acuerdo con el "valor" asociado.
2.   Escriba un código que permita concatenar dos o más diccionarios en uno solo.
3. Escriba un código que permita generar un diccionario con la siguiente forma: d = {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}.
4. Escriba un código que permita ordenar un diccionario por su llave.
5. Escriba un programa que tome sume los valores asociados a la llave, cuando esta última sea igual.
"""

# Ejercicio 1:
# Import the 'operator' module, which provides functions for common operations like sorting.
import operator

# Create a dictionary 'd' with key-value pairs.
d = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}

# Print the original dictionary 'd'.
print('Original dictionary : ',d)

# Sort the items (key-value pairs) in the dictionary 'd' based on the values (1st element of each pair).
# The result is a list of sorted key-value pairs.
sorted_d = sorted(d.items(), key=operator.itemgetter(1))

# Print the dictionary 'sorted_d' in ascending order by value.
print('Dictionary in ascending order by value : ',sorted_d)

# Convert the sorted list of key-value pairs back into a dictionary.
# The 'reverse=True' argument sorts the list in descending order by value.
sorted_d = dict( sorted(d.items(), key=operator.itemgetter(1), reverse=True))

# Print the dictionary 'sorted_d' in descending order by value.
print('Dictionary in descending order by value : ',sorted_d)

# Ejercicio 2:
# Create three dictionaries 'dic1', 'dic2', and 'dic3' with key-value pairs.
dic1 = {1: 10, 2: 20}
dic2 = {3: 30, 4: 40}
dic3 = {5: 50, 6: 60}

# Create an empty dictionary 'dic4' that will store the combined key-value pairs from 'dic1', 'dic2', and 'dic3'.
dic4 = {}

# Iterate through each dictionary ('dic1', 'dic2', and 'dic3') using a loop.
for d in (dic1, dic2, dic3):
    # Update 'dic4' by adding the key-value pairs from the current dictionary 'd'.
    dic4.update(d)

# Print the combined dictionary 'dic4' containing all the key-value pairs from 'dic1', 'dic2', and 'dic3'.
print(dic4)

# Ejercicio 4:
# Create a dictionary 'color_dict' with color names as keys and their corresponding color codes in hexadecimal format as values.
color_dict = {
    'red': '#FF0000',
    'green': '#008000',
    'black': '#000000',
    'white': '#FFFFFF'
}

# Iterate through the keys of the 'color_dict' dictionary after sorting them in lexicographical order.
for key in sorted(color_dict):
    # Print each key-value pair where '%s' is a placeholder for the key and its associated color code.
    print("%s: %s" % (key, color_dict[key]))

"""# Funciones en Python

Una función no es más que un bloque de código aislado que lleva a cabo una tarea específica.

Las funciones son muy útiles en programación debido a que eliminan los innecesarios y excesivos ¨copia y pega¨ de código a través de un programa.

Si una acción específica es requerida a menudo en tu código, es un buen indicador de la necesidad de escribir una función. Las funciones son para ser reutilizadas.

Las funciones también te ayudan a organizar tu código.

* Esto cumple con el principio de desarrollo de software DRY (Don't Repeat Yourself), que significa; no te repitas.

* El código dentro de una función  se ejecuta solo cuando la función es llamada.

* Las funciones pueden aceptar argumentos y valores predeterminados, pudiendo o no devolver valores una vez que se haya ejecutado el código.

## Definiendo una función:

La sintaxis general para crear una función en Python es:
"""

def nombre_funcion(parametros):
    pass

"""Veamos que, para una función:

* **def**: es una palabra reservada que indica a Python que una nueva función está siendo definida.

* Luego viene una función con un nombre válido de tu elección. Los nombres válidos empiezan con una letra o un guion bajo, pero pueden incluir números. Las palabras suelen ser minúsculas y separadas por guiones bajos. Es importante saber que los nombres de función no pueden ser palabras reservadas de Python.

* Luego, tenemos los paréntesis, (). Al interior de ellos, puede haber cero, uno, o más parámetros opcionales,  separados por coma con sus valores predeterminados. Estos valores son pasados a la función.
* A continuación los dos puntos, :, los cuales finalizan la definición de la función.

* Consiguientemente, es necesaria una nueva línea, seguida por un nivel de identación(pudiendo usar cuatro espacios con tu keyboard, o bien un espacio con la tecla Tab). La identación es importante, permite a Python reconocer qué código pertenecerá a la función.

* La siguiente parte de la función representa el "body", o si lo prefieres, su contenido o estructura. Esta parte contiene las acciones que ejecutará Python cuando la función sea llamada.
"""

def saludo(nombre):
   print("Hola " + nombre)

saludo('Julieta')

"""Ejemplo con números primos:"""

# Determinar numero primos:
def es_primo(n):
  for i in range(2, n):
    if n%i == 0:
      return False
  return True

def numeros_primos(nums):
  primos = []
  for n in nums:
    if es_primo(n):
      primos.append(n)
  return primos

# Números primos:
numeros = [1, 8, 3, 9, 10, 25, 12, 33]
nums_primos = numeros_primos(numeros)
print(f"Lista original: {numeros}")
print(f"Numeros primos de la lista: {nums_primos}")

"""# Módulo y Librerías de Python: Definición y uso

Un **módulo** es un archivo de Python cuyos objetos (funciones, clases, excepciones, etc.) pueden ser accedidos desde otro archivo. Esta es una forma eficiente de administrar nuestro código para que sea fácil de leer, reutilizable, escalable y apto para compartir con otros proyectos.

Generalmente, el nombre del módulo es el nombre del archivo con extensión .py. Los módulos no se cargan a menos que los ejecutemos en el intérprete de Python o los llamemos dentro de un programa. En Python, hay módulos en una biblioteca estándar, directorio actual o directorios que contienen archivos .py (de hecho, cada archivo con extensión .py es un módulo).

De otra parte, una **librería** no son más que conjuntos/paquetes de funciones/métodos que extienden la funcionalidad básica del lenguaje. Estas librerías generalmente están escritas en Python, pero también pueden ser desarrolladas en otros lenguajes de programación. A tráves de éstas se pueden se pueden generar software reutilizable y acceder a funcionalidades adicionales sin tener que escribir todo desde cero.

Algunas librerías populares de Python son:

* **NumPy**: Para cálculos numéricos y manipulación de matrices y arreglos.
* **Pandas**: Para manipulación y análisis de datos estructurados en forma de tablas.
* **Matplotlib** y Seaborn: Para visualización de datos y creación de gráficos.
* **Requests**: Para realizar solicitudes HTTP y trabajar con APIs web.
* **Flask y Django**: Para crear aplicaciones web y sitios web.
* **TensorFlow y PyTorch**: Para la implementación de aprendizaje profundo y machine learning.
* **SQLite3 y SQLAlchemy**: Para trabajar con bases de datos.

## Uso de librería y/o métodos:

Consideremos, por ejemplo, un archivo aritmetica.py que contenga las siguientes definiciones.


Podemos acceder a ellas desde otro archivo de Python ubicado en la misma ruta importando el módulo.

```
def sumar(a, b):
    return a + b

def restar(a, b):
    return a - b

def mult(a, b):
    return a * b

def div(a, b):
    return a / b
```

```
import aritmetica
print(aritmetica.sumar(7, 5))
```

En el caso anterior estamos importando toda la librería/módulo llamado aritmetica. Sin embargo, algunas veces sólo queremos importar una función/módulo para nuestro trabajo. En este caso hacemos uso de la siguiente sintáxis:

`from aritmetica import sumar`

En este caso, estaríamos importando sólo la función/módulo de suma y no todo el conjunto de funciones/módulos.

para su uso, simplemente sería algo como:


```
from aritmetica import sumar
print(sumar(7, 5))
```

**NOTA:**
Es muy importante que cuando ustedes estén creando sus propias librerías y/o módulos, en la carpeta donde están guardando sus archivos con extensión .py, creen un archivo en blanco llamado:
```
__init__.py
```

Este archivo, le va a decir al intérprete de Python que la carpeta actual se configure para permitir importar los archivos .py como módulos en cualquier parte del código y en otros códigos.

## Ejemplos:
"""

